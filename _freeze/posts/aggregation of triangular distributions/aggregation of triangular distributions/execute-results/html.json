{
  "hash": "576179fa74c5065a80c3ebbc24944568",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Aggregation of Triangular Distributions\"\nauthor: \"Johannes Buck\"\ndate: \"2024-06-23\"\ncategories: [statistics, risk management]\ndescription: Aggregation of triangular distributions with Monte Carlo simulation and convulutionn.\nimage: aggregation of triangular distributions.png\n---\n\n\n# Aggregation of triangular distributions\n\nAggregating multiple triangular distributions can be challenging because the resulting distribution is not necessarily triangular.\n\n## Approach with Monte Carlo simulation\n\n1.  **Define Individual Triangular Distributions:** Each triangular distribution is defined by its minimum (a), most likely (b), and maximum (c) values. Let's assume we have $n$ triangular distributions $(a_i, b_i, c_i)$ where $i$ ranges from 1 to $n$.\n\n2.  **Sampling from each distribution:** Since the sum of triangular distributions is not necessarily triangular, one common approach is to use Monte Carlo simulation. This involves:\n\n    -   Generating a large number of random samples from each triangular distribution.\n    -   Summing these samples to create an empirical distribution of the aggregate.\n\n3.  **Monte Carlo Simulation:**\n\n    -   For each triangular distribution, generate $m$ random samples using the inverse transform sampling method or built-in functions from statistical libraries.\n    -   Sum the corresponding samples from each distribution to get an aggregated sample.\n    -   Repeat the process to create a large number of aggregated samples.\n\n4.  **Analyzing the aggregate distribution:**\n\n    -   Use the aggregated samples to create a histogram or kernel density estimate to visualize the aggregate distribution.\n    -   Calculate summary statistics (mean, median, variance, etc.) to understand the central tendency and spread of the aggregate distribution.\n\n### Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Aggregation of triangular distributions with Monte Carlo simulation\n\n# Load necessary library\nlibrary(triangle)\n\n# Define the triangular distributions\ndistributions <- list(\n  c(1, 3, 5),\n  c(2, 4, 6),\n  c(0, 2, 4)\n)\n\n# Number of samples\nnum_samples <- 10000\n\n# Generate samples from each triangular distribution\nsamples <- lapply(distributions, function(params) {\n  rtriangle(num_samples, a = params[1], b = params[3], c = params[2])\n})\n\n# Sum the samples to get the aggregated samples\naggregated_samples <- Reduce(`+`, samples)\n\n# Plot the histogram of the aggregated samples\nhist(aggregated_samples, col=\"skyblue\", breaks = 50, probability = TRUE,\n     main = \"Aggregated Distribution\", xlab = \"Value\", ylab = \"Density\")\n```\n\n::: {.cell-output-display}\n![](aggregation-of-triangular-distributions_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Calculate and print summary statistics\nmean_value <- mean(aggregated_samples)\nmedian_value <- median(aggregated_samples)\nstd_dev <- sd(aggregated_samples)\n\ncat(\"Mean:\", mean_value, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMean: 8.997505 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Median:\", median_value, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMedian: 9.00486 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Standard Deviation:\", std_dev, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStandard Deviation: 1.430559 \n```\n\n\n:::\n:::\n\n\n### Considerations for interpretation\n\n1.  **Non-triangular shape:** The aggregate distribution will likely not be triangular. It might resemble a normal distribution (Central Limit Theorem) if the number of distributions is large and they are independent.\n\n2.  **Central tendency:** The mean of the aggregate distribution will be the sum of the means of the individual distributions.\n\n3.  **Variance:** The variance of the aggregate distribution is the sum of the variances of the individual distributions if they are independent.\n\n4.  **Dependence:** If the triangular distributions are not independent, the aggregate distribution can be skewed or have other characteristics that reflect the dependencies.\n\n5.  **Sample size:** The accuracy of the Monte Carlo simulation depends on the number of samples. More samples provide a better approximation of the true aggregate distribution.\n\nBy considering these factors, you can aggregate multiple triangular distributions and interpret the results effectively.\n\n::: callout-note\n## Central limit theorem\n\nThe central limit theorem is a fundamental result in probability theory that states that the distribution of the sample mean of independent random variables will approach a normal distribution as the sample size increases. This holds regardless of the shape of the population distribution. The theorem implies that the sample mean is a good estimator of the population mean, and that it becomes more accurate as the sample size grows.\n:::\n\n## Analytical approach\n\nThere is an analytical approach to aggregating triangular distributions, although it is generally more complex and less straightforward than Monte Carlo simulation.\n\n1.  **Understand the sum of two triangular distributions:** The sum of two triangular distributions is not necessarily triangular. Instead, it forms a piecewise linear distribution that can be described in terms of convolution. The convolution of two triangular distributions results in a distribution that is piecewise quadratic.\n\n2.  **Convolution of two triangular distributions:** The probability density function (PDF) of the sum of two independent triangular distributions can be obtained by convolving their individual PDF. If $X \\sim \\text{Triangular}(a_1, b_1, c_1)$ and $Y \\sim \\text{Triangular}(a_2, b_2, c_2)$, the PDF of $Z = X + Y$ can be derived from the convolution of the PDF of $X$ and $Y$.\n\n3.  **Iterative convolution for multiple distributions:** For more than two distributions, you would iteratively convolve the resulting distribution with the next triangular distribution in the series. This process can be very complex analytically, especially for a large number of distributions.\n\n### Practical consideration\n\nWhile the analytical approach can be worked out for small numbers of distributions and can be insightful for understanding the behavior of the sum of distributions, it becomes highly complex and unwieldy for larger numbers of distributions.\n\n### Conclusion\n\nFor practical purposes, especially with more than two distributions, the Monte Carlo simulation approach is generally preferred due to its simplicity and ease of implementation. It provides a good approximation of the aggregate distribution without the need for complex analytical derivations.\n\nIf you need to proceed with an analytical solution for specific cases or for a small number of distributions, you might need to consult more detailed statistical or mathematical texts on the convolution of probability distributions, or use specialized mathematical software to handle the convolutions.\n\n### Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convolution of two triangular distributions\n\n# Define the triangular PDF function\ntriangular_pdf <- function(x, a, b, c) {\n  ifelse(x < a | x > c, 0, \n         ifelse(x < b, (2 * (x - a)) / ((b - a) * (c - a)), \n                (2 * (c - x)) / ((c - b) * (c - a))))\n}\n\n# Convolution of two triangular PDFs\nconvolution_pdf <- function(z, a1, b1, c1, a2, b2, c2) {\n  # Integration limits\n  lower <- max(a1, z - c2)\n  upper <- min(c1, z - a2)\n  \n  # Handle cases where integration is not possible\n  if (lower > upper) {\n    return(0)\n  }\n  \n  # Integrate using the integrate function\n  result <- integrate(function(x) {\n    sapply(x, function(xi) triangular_pdf(xi, a1, b1, c1) * triangular_pdf(z - xi, a2, b2, c2))\n  }, lower, upper)\n  \n  return(result$value)\n}\n\n# Create a sequence of x values for plotting\nx_values <- seq(0, 7, length.out = 1000)\n\n# Define the parameters of the two triangular distributions\na1 <- 1; b1 <- 3; c1 <- 5\na2 <- 2; b2 <- 4; c2 <- 6\n\n# Calculate the PDFs for both distributions\npdf1 <- sapply(x_values, triangular_pdf, a1, b1, c1)\npdf2 <- sapply(x_values, triangular_pdf, a2, b2, c2)\n\n# Plot the first distribution\nplot(x_values, pdf1, xlim=c(0,12), ylim=c(0,0.6), type = \"l\", col = \"blue\", lwd = 1, \n     xlab = \"x\", ylab = \"Density\", main = \"Convolution of two triangular distributions\")\n\n# Add the second distribution to the plot\nlines(x_values, pdf2, col = \"purple\", lwd = 1)\n\n# Add a legend\nlegend(\"topright\", legend = c(\"Triangular PDF(1, 3, 5)\", \"Triangular PDF(2, 4, 6)\", \"PDF of convolution\"), \n       col = c(\"blue\", \"purple\", \"lightblue\"), lwd = 1)\n\n\n# Generate a range of z values for plotting\nz_values <- seq(a1 + a2, c1 + c2, length.out = 1000)\n\n# Calculate the convolution PDF values for each z\nconvolution_values <- sapply(z_values, function(z) convolution_pdf(z, a1, b1, c1, a2, b2, c2))\n\n# Plot the resulting convolution PDF\nlines(z_values, convolution_values, xlim=c(0,12), ylim=c(0,0.6), type = 'l', col = 'lightblue', lwd = 1,\n      main = 'Convolution of two triangular distributions',\n      xlab = 'Value', ylab = 'Density')\n```\n\n::: {.cell-output-display}\n![](aggregation-of-triangular-distributions_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\n## Convolution\n\nConvolution is a mathematical operation on two functions (𝑓 and 𝑔) that produces a third function (𝑓∗𝑔). Convolution is defined as the integral of the product of the two functions after one is reflected about the y-axis and shifted. The integral is evaluated for all values of shift, producing the convolution function. The choice of which function is reflected and shifted before the integral does not change the integral result. Graphically, it expresses how the \"shape\" of one function is modified by the other.\n:::\n",
    "supporting": [
      "aggregation-of-triangular-distributions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}